// the caching lock server implementation

#include "lock_server_cache.h"
#include <sstream>
#include <stdio.h>
#include <unistd.h>
#include <arpa/inet.h>

static void *
revokethread(void *x)
{
  lock_server_cache *sc = (lock_server_cache *) x;
  sc->revoker();
  return 0;
}

static void *
retrythread(void *x)
{
  lock_server_cache *sc = (lock_server_cache *) x;
  sc->retryer();
  return 0;
}

lock_server_cache::lock_server_cache()
{
  pthread_t th;
  int r = pthread_create(&th, NULL, &revokethread, (void *) this);
  assert (r == 0);
  r = pthread_create(&th, NULL, &retrythread, (void *) this);
  assert (r == 0);
}

void
lock_server_cache::revoker()
{

  // This method should be a continuous loop, that sends revoke
  // messages to lock holders whenever another client wants the
  // same lock
  while(1){
    //if something in revoke queue, send it 
    for(std::list<server_lock *>::iterator it=revoke_list.begin();it!=revoke_list.end();){
      lock_protocol::lockid_t lid = (*it)->lock_id;
      int se_num= (*it)->sequence_num;
      int clt = (*it)->owned_client_id;
      rpcc *scrpc = rpcc_map[clt];
      int r;
      int ret = scrpc->call(rlock_protocol::revoke, clt, se_num, lid, r);
      if(ret == rlock_protocol::OK){  // if successfully send revoke (seq # is right)
	//delete the items in the queue
	it = revoke_list.erase(it);
      }
    }
  }
}


void
lock_server_cache::retryer()
{

  // This method should be a continuous loop, waiting for locks
  // to be released and then sending retry messages to those who
  // are waiting for it.
  while(1){
    for(std::list<server_lock *>::iterator it=retry_list.begin();it!=retry_list.end();){
      lock_protocol::lockid_t lid = (*it)->lock_id;
      int se_num= (*it)->sequence_num;
      int clt = (*it)->acquiring_client_id;
      rpcc *scrpc = rpcc_map[clt];
      int r;
      int ret = scrpc->call(rlock_protocol::retry, clt, se_num, lid, r);
      if(ret == rlock_protocol::OK){  // if successfully send revoke (seq # is right)
	//delete the items in the queue
	it = revoke_list.erase(it);
      }
    }
  }
}

//rpcc* 
//lock_server_cache::get_rpcc(int clt)
//{
//  return rpcc_map
//}

lock_protocol::status
lock_server_cache::handleAcquire(int clt, std::string id, int seq, lock_protocol::lockid_t lid, int &r)
{
  if(addr_map.count(clt) == 0){  //no addr in this clt
    addr_map[clt]=id;
    sockaddr_in dstsock;
    make_sockaddr(id.c_str(), &dstsock);
    rpcc* srpc = new rpcc(dstsock);
    if (srpc->bind() < 0) {
      printf("lock_server_cache: call bind\n");
    }
    rpcc_map[clt] = srpc;
  }
  //  addr_map[clt] = id; 
  server_lock *l = server_locks[lid];
  l->acquiring_client_id = clt;
  if(l->sestat == LOCKED){
    //add to revoke queue
    revoke_list.push_back(l);
    return lock_protocol::RETRY;
  }
  if(l->sestat == FREE){
    l->sestat = LOCKED;
    l->owned_client_id = clt;
    return lock_protocol::OK;
  }
}

lock_protocol::status
lock_server_cache::handleRelease(int clt, std::string id,int seq, lock_protocol::lockid_t lid, int &r)
{
  //  addr_map[clt] = id;
  server_lock *l = server_locks[lid];
  assert(l->sestat == LOCKED);
  l->sestat = FREE;
  //add to retry queue

}
