// RPC stubs for clients to talk to lock_server, and cache the locks
// see lock_client.cache.h for protocol details.

#include "lock_client_cache.h"
#include "rpc.h"
#include <sstream>
#include <iostream>
#include <stdio.h>



static void *
releasethread(void *x)
{
  lock_client_cache *cc = (lock_client_cache *) x;
  cc->releaser();
  return 0;
}

int lock_client_cache::last_port = 0;

lock_client_cache::lock_client_cache(std::string xdst, 
				     class lock_release_user *_lu)
  : lock_client(xdst), lu(_lu)
{
  srand(time(NULL)^last_port);
  rlock_port = ((rand()%32000) | (0x1 << 10));
  const char *hname;
  // assert(gethostname(hname, 100) == 0);
  hname = "127.0.0.1";
  std::ostringstream host;
  host << hname << ":" << rlock_port;
  id = host.str();
  last_port = rlock_port;
  rpcs *rlsrpc = new rpcs(rlock_port);
  /* register RPC handlers with rlsrpc */
  rlsrpc->reg(rlock_protocol::retry, this, &lock_client_cache::handleRetry); 
  rlsrpc->reg(rlock_protocol::revoke, this, &lock_client_cache::handleRevoke);
  seq_num=0; //initialize the seq num
  pthread_t th;
  int r = pthread_create(&th, NULL, &releasethread, (void *) this);
  assert (r == 0);
}


void
lock_client_cache::releaser()
{

  // This method should be a continuous loop, waiting to be notified of
  // freed locks that have been revoked by the server, so that it can
  // send a release RPC.
  while(1){
    pthread_mutex_lock(&release_queue_mutex);  //queue mutex
    //    printf("[releaser]");
    //check if release queue is empty, if empty, wait the thread
    if(!revoke_list.empty()){
      for(std::list<client_lock *>::iterator it = revoke_list.begin();it !=revoke_list.end();){
	//	pthread_mutex_lock(&client_mutex);
	if((*it)->clstat == RELEASING){
	  printf("[releaser ]: prepare for releasing\n");
	  pthread_mutex_lock(&client_mutex);
	  //call release rpc
	  int r;
	  int ret = cl->call(lock_protocol::release, cl->id(), id, (*it)->seq_id, (*it)->lock_id,r);
	  //release succeed
	  (*it)->clstat = NONE;
	  it = revoke_list.erase(it);
	  //wake up the waiting thread
	  pthread_cond_broadcast(&client_cond);
	  pthread_mutex_lock(&client_mutex);
	}else{
	  it++;
	}
	//	pthread_mutex_unlock(&client_mutex);
      }

    }else{
      pthread_cond_wait(&release_queue_cond, &release_queue_mutex);
      printf("[releaser]: releaser wake up\n");
    }
    pthread_mutex_unlock(&release_queue_mutex);
  }


}


lock_protocol::status
lock_client_cache::acquire(lock_protocol::lockid_t lid)
{
  //remember to send id  to the server
  pthread_mutex_lock(&client_mutex);
  printf("[acquire ]: is invoked\n");
  client_lock *l= client_locks[lid];
  pthread_t tid = pthread_self();
  l->acquire_queue.push(tid);
  //  acquire_queue1.push(tid);
  while(l->clstat != FREE || l->acquire_queue.front() != tid){   
    //includes none , locked , acquiring , releasing
    
    if(l->clstat == NONE && l->acquire_queue.front()==tid){   //only when the order is right 
      l->clstat = ACQUIRING;
      //call rpc to server , with sequence number
      int r;
      seq_num++;  //generate an seq number
      l->seq_id = seq_num;
      int ret = cl->call(lock_protocol::acquire, cl->id(), id, seq_num, lid, r);
      if(ret == lock_protocol::OK){
	break;  //successfully get the lock
      }
    }
    pthread_cond_wait(&client_cond, &client_mutex); //wait
  }
  l->clstat = LOCKED;   //set the lock locked
  l->releasing_flag = false;
  l->acquire_queue.pop();
  pthread_mutex_unlock(&client_mutex);
  return lock_protocol::OK;
}

lock_protocol::status
lock_client_cache::release(lock_protocol::lockid_t lid)
{
  pthread_mutex_lock(&client_mutex);
  printf("[release ]: is invoked\n");
  client_lock *l = client_locks[lid];
  assert(l->clstat == LOCKED);
  //if the locked is not in the release queue
  if(l->clstat == LOCKED && l->releasing_flag == false ){
    l->clstat = FREE;
    pthread_cond_broadcast(&client_cond);
  }
  //if clstat is in the queue
  if(l->clstat == LOCKED && l->releasing_flag == true ){
    l->clstat = RELEASING;
    l->lock_id = lid;
  }
  pthread_mutex_unlock(&client_mutex);
  return lock_protocol::OK;
}


rlock_protocol::status
lock_client_cache::handleRevoke(int clt, int seq, lock_protocol::lockid_t lid, int &r)
{
  //dont forget sequence number 
  printf("[handleRevoke]: invoked\n");
  pthread_mutex_lock(&client_mutex);
  client_lock *l = client_locks[lid];
  //the lock can only be locked or free
  assert(l->clstat == FREE || l->clstat == LOCKED);
  //only if the seq # = l seq #  revoke right
  if(seq != l->seq_id){
    pthread_mutex_unlock(&client_mutex);
    return rlock_protocol::RPCERR;
  }
  l->releasing_flag = true;
  if(l->clstat == FREE){ //if free
    l-> clstat = RELEASING;
  }
  //if not free add to the queue
  if(l->clstat != FREE){
    //do nothing
  }
  pthread_mutex_unlock(&client_mutex);

  pthread_mutex_lock(&release_queue_mutex);  //lock queue lock
  //add to the queue
  revoke_list.push_back(l);
  //wake the releaser thread
  pthread_cond_signal(&release_queue_cond);
  pthread_mutex_unlock(&release_queue_mutex);  //unlock queue lock
  
  //  pthread_mutex_unlock(&client_mutex);

  return rlock_protocol::OK;  //successfully send 'revoke' rpc
}

rlock_protocol::status
lock_client_cache::handleRetry(int clt, int seq, lock_protocol::lockid_t lid, int &r)
{
  //handller for retry rpc, wake up the waiting thread for "acquire"
  printf("[handleRetry]: invoked\n");
  pthread_mutex_lock(&client_mutex);
  client_lock *l = client_locks[lid];
  if( seq != l->seq_id){
    pthread_mutex_unlock(&client_mutex);
    return rlock_protocol::RPCERR;
  }
  l->clstat = NONE;
  //wake up the blocked thread
  pthread_cond_broadcast(&client_cond);

  pthread_mutex_unlock(&client_mutex);
  return rlock_protocol::OK; // successfully send retry rpc
}
